-------------------------------------------------------------------------------
-- Title      : Accelerator Adapter
-- Project    :
-------------------------------------------------------------------------------
-- File       : xd_oarg_s2s_adapter.vhd
-- Author     : rmg/jn
-- Company    : Xilinx, Inc.
-- Created    : 2012-09-05
-- Last update: 2013-01-22
-- Platform   :
-- Standard   : VHDL'93
-------------------------------------------------------------------------------
-- Description:
-------------------------------------------------------------------------------
-- (c) Copyright 2012 Xilinx, Inc. All rights reserved.
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author  Description
-- 2012-09-05  1.0      rmg/jn  Created
-------------------------------------------------------------------------------
-- ****************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- ****************************************************************************
-------------------------------------------------------------------------------

-- Design note: The main issue in this module is TLAST generation, specially in
-- the case where AXI stream wisth is not the same as accelerator data width.
-- Last data beat generated by accelerator is the one generated just before
-- ap_done is generated.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library unisim;
use unisim.vcomponents.all;


library axis_accelerator_adapter_v2_1_6;
use axis_accelerator_adapter_v2_1_6.xd_adapter_pkg.all;
use axis_accelerator_adapter_v2_1_6.srl_fifo_32_wt;
use axis_accelerator_adapter_v2_1_6.s2s_async_fifo_wt;


entity xd_oarg_s2s_adapter is
  generic (
    -- System generics:
    C_FAMILY              : string ;     -- Xilinx FPGA family
    C_MTBF_STAGES         : integer;
    C_M_AXIS_TDATA_WIDTH  : integer;
    C_M_AXIS_TUSER_WIDTH  : integer;
    C_M_AXIS_TID_WIDTH    : integer;
    C_M_AXIS_TDEST_WIDTH  : integer;

    C_AP_ARG_DATA_WIDTH   : integer;
    C_AP_ARG_ADDR_WIDTH   : integer;
    C_MULTIBUFFER_DEPTH   : integer);
  port (
    -- Output streams
    M_AXIS_ACLK       : in  std_logic;
    M_AXIS_ARESETN    : in  std_logic;
    M_AXIS_TVALID     : out std_logic;
    M_AXIS_TREADY     : in  std_logic;
    M_AXIS_TDATA      : out std_logic_vector(C_M_AXIS_TDATA_WIDTH-1 downto 0);
    M_AXIS_TSTRB      : out std_logic_vector(C_M_AXIS_TDATA_WIDTH/8-1 downto 0);
    M_AXIS_TKEEP      : out std_logic_vector(C_M_AXIS_TDATA_WIDTH/8-1 downto 0);
    M_AXIS_TLAST      : out std_logic;
    M_AXIS_TID        : out std_logic_vector(C_M_AXIS_TID_WIDTH-1 downto 0);
    M_AXIS_TDEST      : out std_logic_vector(C_M_AXIS_TDEST_WIDTH-1 downto 0);
    M_AXIS_TUSER      : out std_logic_vector(C_M_AXIS_TUSER_WIDTH-1 downto 0);
    ---
    sw_length         : in  std_logic_vector(31 downto 0);
    sw_length_we      : in  std_logic;
    use_sw_length     : in  std_logic;
    host_oarg_tdest   : in  std_logic_vector(C_M_AXIS_TDEST_WIDTH-1 downto 0);
    ---
    ap_clk            : in  std_logic;
    ap_rst_sync       : in  std_logic;
    ap_rst            : in  std_logic;
    ap_oarg_din       : in  std_logic_vector(C_AP_ARG_DATA_WIDTH-1 downto 0);
    ap_oarg_we        : in  std_logic;
    ap_oarg_full_n    : out std_logic;
    ap_arg_rqt        : out std_logic;
    ap_arg_ack        : in  std_logic;

    ap_start          : in  std_logic;
    ap_done           : in  std_logic;

    none              : out std_logic);
end entity;

architecture rtl of xd_oarg_s2s_adapter is
  signal axis_data   : std_logic_vector(C_M_AXIS_TDATA_WIDTH-1 downto 0);
  signal axis_keep   : std_logic_vector(C_M_AXIS_TDATA_WIDTH/8-1 downto 0);
  -- pragma translate_off
  signal axis_start  : std_logic;
  signal axis_end    : std_logic;
  -- pragma translate_on
  signal axis_last   : std_logic;
  signal axis_vld    : std_logic;
  signal axis_rdy    : std_logic;
  signal axis_rst    : std_logic;
  signal axis_rst1    : std_logic;
  signal axis_rst2    : std_logic;
  signal axis_trf_ok : std_logic;
  signal ap_rst_vec  : std_logic_vector(0 downto 0);
  signal ap_rst_reg  : std_logic;
--  signal ap_rst_sync : std_logic;
--  signal ap_rst_sync1 : std_logic;
  signal ap_rst_axi  : std_logic;
  signal ap_rst_axi1  : std_logic;

  -- SW_LENGTH_WIDTH is defined in xd_adapter_pkg
  signal sw_length_wr : std_logic_vector(SW_LENGTH_WIDTH-1 downto 0);
  signal sw_length_rd : std_logic_vector(SW_LENGTH_WIDTH-1 downto 0);
  signal sw_length_we_vector       : std_logic_vector(0 downto 0);
  signal sw_length_we_rd       : std_logic;
  signal sw_length_we_rd_vector       : std_logic_vector(0 downto 0);
  signal xd_sw_length        : std_logic_vector(SW_LENGTH_WIDTH-1 downto 0);
  signal xd_sw_length_vld    : std_logic;
  signal xd_sw_length_rdy    : std_logic;
  signal sw_length_fifo_dout : std_logic_vector(SW_LENGTH_WIDTH-1 downto 0);

      ATTRIBUTE async_reg           : STRING;
  ATTRIBUTE async_reg OF ap_rst_axi  : SIGNAL IS "true";
        ATTRIBUTE async_reg OF axis_rst1    : SIGNAL IS "true"; 
      ATTRIBUTE async_reg OF axis_rst    : SIGNAL IS "true"; 
--        ATTRIBUTE async_reg OF ap_rst_sync1    : SIGNAL IS "true"; 
--      ATTRIBUTE async_reg OF ap_rst_sync    : SIGNAL IS "true"; 



begin


      prd0: PROCESS (M_AXIS_ACLK, M_AXIS_ARESETN)
      BEGIN
       -- Register Stage #1 
        IF (M_AXIS_ARESETN = '0') THEN
          axis_rst1 <= '1';
          axis_rst <= '1';
        ELSIF (M_AXIS_ACLK'event and M_AXIS_ACLK = '1') THEN
          axis_rst1 <= '0';
          axis_rst <= axis_rst1;
        END IF;
        END PROCESS prd0;




  M_AXIS_TVALID <= axis_vld;
  M_AXIS_TDATA  <= axis_data;
  M_AXIS_TSTRB  <= (others => '0');
  M_AXIS_TKEEP  <= axis_keep;
  M_AXIS_TLAST  <= axis_last;
  M_AXIS_TID    <= (others => '0');
  M_AXIS_TDEST  <= host_oarg_tdest;
  M_AXIS_TUSER  <= (others => '0');


  axis_trf_ok <= axis_vld and axis_rdy;

 --     PROCESS (ap_clk)
 --     BEGIN
 --       IF (ap_clk'event and ap_clk = '1') THEN
 --         ap_rst_reg <= ap_rst;
 --       END IF;
 --       END PROCESS;
      
--      prd1: PROCESS (M_AXIS_ACLK)
--      BEGIN
--       -- Register Stage #1 
--        IF (M_AXIS_ACLK'event and M_AXIS_ACLK = '1') THEN
--          ap_rst_sync1 <= ap_rst;
--          ap_rst_sync <= ap_rst_sync1;
--        END IF;
--        END PROCESS prd1;

	axis_rst2 <= axis_rst or ap_rst_sync; 

      prd2: PROCESS (M_AXIS_ACLK, axis_rst2)
      BEGIN
       -- Register Stage #1 
        IF (axis_rst2 = '1') THEN
          ap_rst_axi1 <= '1';
          ap_rst_axi <= '1';
        ELSIF (M_AXIS_ACLK'event and M_AXIS_ACLK = '1') THEN
          ap_rst_axi1 <= '0';
          ap_rst_axi <= ap_rst_axi1;
        END IF;
        END PROCESS prd2;



--      rst_sync : entity  axis_accelerator_adapter_v2_1_6.cdc_sync
--        generic map (
--        C_CDC_TYPE                 => 0,
--        C_RESET_STATE              => 1,
--        C_SINGLE_BIT               => 1,
--        C_FLOP_INPUT               => 0,
--        C_VECTOR_WIDTH             => 1,
--        C_MTBF_STAGES              => 2
--        )
--        port map (
--        prmry_aclk                 => '0',
--        prmry_resetn               => '0',
--        prmry_in                   => ap_rst,
--        prmry_vect_in              => (others=>'0'),
--
--        scndry_aclk                => M_AXIS_ACLK,
--        scndry_resetn              => M_AXIS_ARESETN,
--        scndry_out                 => ap_rst_axi,
--        scndry_vect_out            => open
--        );




  -- SW programmable length:

--  sw_length_wr <= sw_length(SW_LENGTH_WIDTH-1 downto 0);
    sw_length_rd <= sw_length(SW_LENGTH_WIDTH-1 downto 0);
  sw_length_we_vector(0) <= sw_length_we;
  sw_length_we_rd        <= sw_length_we_rd_vector(0);

   wr_stg_inst: ENTITY axis_accelerator_adapter_v2_1_6.synchronizer_ff
    GENERIC MAP (
     C_HAS_RST => 1,
     C_WIDTH   => 1
     )
    PORT MAP ( 
     RST       => axis_rst,
     CLK       => M_AXIS_ACLK,   
     D         => sw_length_we_vector,
     Q         => sw_length_we_rd_vector
     );    

--       SW_LENGTH_SYNC : entity  axis_accelerator_adapter_v2_1_6.cdc_sync
--        generic map (
--        C_CDC_TYPE                 => 1,
--        C_RESET_STATE              => 0,
--        C_SINGLE_BIT               => 0,
--        C_VECTOR_WIDTH             => SW_LENGTH_WIDTH,
--        C_MTBF_STAGES              => 2
--        )
--        port map (
--        prmry_aclk                 => '0',
--        prmry_resetn               => '0',
--        prmry_in                   => '0',
--        prmry_vect_in              => sw_length_wr,
--
--        scndry_aclk                => M_AXIS_ACLK,
--        scndry_resetn              => axis_rst,
--        scndry_out                 => open,
--        scndry_vect_out            => sw_length_rd
--        );

	
  SW_LENGTH_FIFO : entity axis_accelerator_adapter_v2_1_6.srl_fifo_32_wt
    generic map (
      C_FAMILY => C_FAMILY,
      WIDTH    => SW_LENGTH_WIDTH)
    port map (
      rst      => axis_rst,--ap_rst,
      clk      => M_AXIS_ACLK,
      din      => sw_length_rd,
      din_vld  => sw_length_we_rd,
      din_rdy  => open,
      dout     => xd_sw_length,
      dout_vld => xd_sw_length_vld,
      dout_rdy => xd_sw_length_rdy);

  -----------------------------------------------------

  SAME_WIDTH_GEN : if (C_M_AXIS_TDATA_WIDTH = C_AP_ARG_DATA_WIDTH) generate
    signal tap_0       : std_logic_vector(C_AP_ARG_DATA_WIDTH-1 downto 0);
    signal tap_0_we    : std_logic;
    signal tap_0_vld   : std_logic;
    signal tap_0_rdy   : std_logic;
    signal tap_0_start : std_logic;
    signal tap_0_end   : std_logic;

    constant FIFO_DATA_LSB  : integer := 0;
    constant FIFO_DATA_MSB  : integer := C_AP_ARG_DATA_WIDTH-1;
    constant FIFO_START_BIT : integer := FIFO_DATA_MSB+1;
    constant FIFO_END_BIT   : integer := FIFO_START_BIT+1;
    constant FIFO_WIDTH     : integer := FIFO_END_BIT+1;

    signal fifo_din     : std_logic_vector(FIFO_WIDTH-1 downto 0);
    signal fifo_dout    : std_logic_vector(FIFO_WIDTH-1 downto 0);
    signal fifo_din_vld : std_logic;
    signal fifo_din_rdy : std_logic;

    type state_type is (
      -- pragma translate_off
      stop,
      -- pragma translate_on
      idle,
      running,
      pending_last);
    signal state : state_type;

    -- tap_0 is an extra position in the FIFO; substract one
    constant FIFO_DEPTH : integer := (2**C_AP_ARG_ADDR_WIDTH)-1;

    type axis_state_type is (
      -- pragma translate_off
      stop,
      -- pragma translate_on
      idle,
      running,
      discarding,
      padding);

    signal axis_state      : axis_state_type;
    signal apply_sw_length : std_logic;

    -- Output FIFO signals
    signal dout       : std_logic_vector(C_M_AXIS_TDATA_WIDTH-1 downto 0);
    signal dout_start : std_logic;
    signal dout_end   : std_logic;
    signal dout_vld   : std_logic;
    signal dout_rdy   : std_logic;

    constant AXIS_BEAT_CNT_WIDTH : integer := SW_LENGTH_WIDTH;

    -- AXI stream beat counter:
    signal axis_beat_cnt : unsigned(AXIS_BEAT_CNT_WIDTH-1 downto 0);
    signal axis_beat_dec : std_logic;
    signal axis_beat_clr : std_logic;
    signal axis_beat_end : std_logic;

    -- Output stage control:
    signal axis_ce        : std_logic;
    signal axis_we        : std_logic;
    signal next_axis_last : std_logic;
    signal axis_word_vld  : std_logic;

  begin

    process(ap_clk)
    begin
      if(ap_clk'event and ap_clk = '1') then
        if(tap_0_we = '1') then
          tap_0 <= ap_oarg_din;
        end if;
      end if;
    end process;

    process(ap_clk, ap_rst)
    begin
      if(ap_rst = '1') then
        tap_0_vld <= '0';
      elsif(ap_clk'event and ap_clk = '1') then
        if(tap_0_vld = '0' or (tap_0_vld and tap_0_rdy) = '1') then
          tap_0_vld <= tap_0_we;
        end if;
      end if;
    end process;

    process(ap_clk, ap_rst)
    begin
      if(ap_rst = '1') then
        state       <= idle;
        tap_0_start <= '0';
        ap_arg_rqt  <= '1';
      elsif(ap_clk'event and ap_clk = '1') then
        case state is
          when idle =>
            if(ap_start = '1') then
              state       <= running;
              tap_0_start <= '1';
            end if;
          when running =>
            if(ap_done = '1') then
              if (ap_oarg_we = '0' and fifo_din_rdy = '1') then
                state <= idle;
              else
                state      <= pending_last;
                ap_arg_rqt <= '0';
              end if;
            end if;

            if((fifo_din_vld and fifo_din_rdy) = '1') then
              tap_0_start <= '0';
            end if;

          when pending_last =>
            if(tap_0_vld = '0' or (tap_0_vld and fifo_din_rdy) = '1') then
              state      <= idle;
              ap_arg_rqt <= '1';
            end if;
          when others =>
        end case;
      end if;
    end process;

    process(state, ap_oarg_we, tap_0_vld, fifo_din_rdy, ap_done)
    begin
      ap_oarg_full_n <= '0';

      tap_0_we  <= '0';
      tap_0_rdy <= '0';
      tap_0_end <= '0';

      fifo_din_vld <= '0';

      case state is
        when idle =>
          ap_oarg_full_n <= '1';

        when running =>
          -- We enable writes in tap_0 when:
          --  1. it's empty or
          --  2. it's full and we can transfer the contents to the FIFO.
          -- Write is efective when the above conditions are valid and a new
          -- data value is received
          tap_0_we <= ap_oarg_we and (not(tap_0_vld) or (tap_0_vld and fifo_din_rdy));

          -- We enable receive data values if:
          -- 1. tap_0 is empty
          -- 2. tap_0 is full amd it's content can be transfered to the FIFO.
          ap_oarg_full_n <= not(tap_0_vld) or (tap_0_vld and fifo_din_rdy);

          -- We write in the FIFO when tap_0 is full and:
          --  1. arrives a new value at the input or
          --  2. finishes execution (ap_done = '1')
          fifo_din_vld <= tap_0_vld and (ap_oarg_we or ap_done);

          -- If the write in the fifo is efective, we take the contents of tap_0:
          -- take the contents of tap_0 when the FIFO accepts the data value.
          tap_0_rdy <= (tap_0_vld and (ap_oarg_we or ap_done)) and fifo_din_rdy;

          -- Last data value written in the FIFO because we've received an ap_done
          tap_0_end <= tap_0_vld and ap_done;

        when pending_last =>
          tap_0_end <= '1';

          -- Write in the fifo when tap_0 is full and arrives a new data value
          -- at the input
          fifo_din_vld <= tap_0_vld;
          -- In that moment, we take the content of tap_0
          tap_0_rdy    <= tap_0_vld and fifo_din_rdy;

        when others =>
      end case;
    end process;

    fifo_din(FIFO_DATA_MSB downto FIFO_DATA_LSB) <= tap_0;
    fifo_din(FIFO_START_BIT)                     <= tap_0_start;
    fifo_din(FIFO_END_BIT)                       <= tap_0_end;

    FIFO_I : entity axis_accelerator_adapter_v2_1_6.s2s_async_fifo_wt
      generic map (
        C_FAMILY => C_FAMILY,
        C_MTBF_STAGES => C_MTBF_STAGES,
        DEPTH    => FIFO_DEPTH,
        WIDTH    => FIFO_WIDTH)
      port map (
        din      => fifo_din,
        din_vld  => fifo_din_vld,
        din_rdy  => fifo_din_rdy,
        wr_clk   => ap_clk,
        wr_rst   => ap_rst,
        dout     => fifo_dout,
        dout_vld => dout_vld,
        dout_rdy => dout_rdy,
        rd_clk   => M_AXIS_ACLK,
        rd_rst   => axis_rst);

    dout       <= fifo_dout(FIFO_DATA_MSB downto FIFO_DATA_LSB);
    dout_start <= fifo_dout(FIFO_START_BIT);
    dout_end   <= fifo_dout(FIFO_END_BIT);


    process(M_AXIS_ACLK)
    begin
      if(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        if(axis_beat_clr = '1') then
          axis_beat_cnt <= unsigned(xd_sw_length);
        elsif(axis_beat_dec = '1') then
          axis_beat_cnt <= axis_beat_cnt-1;
        end if;
      end if;
    end process;

    axis_beat_end <= '1' when (axis_beat_cnt = 1) else '0';

    process(M_AXIS_ACLK, ap_rst_axi)
    begin
      if(ap_rst_axi = '1') then
        axis_state      <= idle;
        apply_sw_length <= '0';
      elsif(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        case axis_state is
          when idle =>
            -- Don't start until the first data value of a new frame
            -- is available:
            if((dout_vld and dout_start) = '1') then
              apply_sw_length <= use_sw_length;
              -- Wait for a valid SW length if it's going to be used
              if(use_sw_length = '1') then
                if(xd_sw_length_vld = '1') then
                  axis_state <= running;
                end if;
              else
                axis_state <= running;
              end if;
            end if;
          when running =>
            if((axis_ce and dout_vld) = '1') then
              if(apply_sw_length = '0') then
                if(dout_end = '1') then
                  axis_state <= idle;
                end if;
              else
                if(axis_beat_end = '0' and dout_end = '1') then
                  axis_state <= padding;
                elsif(axis_beat_end = '1' and dout_end = '0') then
                  axis_state <= discarding;
                elsif(axis_beat_end = '1' and dout_end = '1') then
                  axis_state <= idle;
                end if;
              end if;
            end if;
          when discarding =>
            if(dout_end = '1') then
              axis_state <= idle;
            end if;
          when padding =>
            if((axis_ce and axis_beat_end) = '1') then
              axis_state <= idle;
            end if;
          when others =>
        end case;
      end if;
    end process;

    process(axis_state, use_sw_length, dout_start, dout_vld, axis_ce, axis_beat_end, dout_end)
    begin
      xd_sw_length_rdy <= '0';
      axis_beat_clr    <= '0';
      axis_beat_dec    <= '0';
      dout_rdy         <= '0';
      axis_we          <= '0';
      next_axis_last   <= '0';
      axis_word_vld    <= '0';

      case axis_state is
        when idle =>
          xd_sw_length_rdy <= use_sw_length and dout_start and dout_vld;
          axis_beat_clr    <= '1';
        when running =>
          axis_we       <= dout_vld;
          dout_rdy      <= axis_ce and dout_vld;
          axis_beat_dec <= axis_ce and dout_vld;

          if(use_sw_length = '0') then
            next_axis_last <= dout_end;
            axis_word_vld  <= '1';
          else
            if(axis_beat_end = '0' and dout_end = '0') then     -- normal opperation
              next_axis_last <= '0';
              axis_word_vld  <= '1';
            elsif(axis_beat_end = '0' and dout_end = '1') then  -- doing padding
              next_axis_last <= '0';
              axis_word_vld  <= '1';
            elsif(axis_beat_end = '1' and dout_end = '0') then  -- doing discarding
              next_axis_last <= '1';
              axis_word_vld  <= '1';
            elsif(axis_beat_end = '1' and dout_end = '1') then  -- sw_length = hw_length
              next_axis_last <= '1';
              axis_word_vld  <= '1';
            end if;
          end if;
        when discarding =>
          dout_rdy <= '1';
        when padding =>
          axis_we        <= '1';
          axis_beat_dec  <= axis_ce;
          next_axis_last <= axis_beat_end;
          axis_word_vld  <= '0';

        when others =>
      end case;
    end process;

    axis_ce <= not(axis_vld) or (axis_vld and axis_rdy);

    process(M_AXIS_ACLK, ap_rst_axi)
    begin
      if(ap_rst_axi = '1') then
        axis_vld <= '0';
      elsif(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        if(axis_ce = '1') then
          axis_vld <= axis_we;
        end if;
      end if;
    end process;

    process(M_AXIS_ACLK)
    begin
      if(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        if(axis_ce = '1') then
          axis_data <= (others => '0');
          if(axis_word_vld = '1') then
            axis_data <= dout;
          end if;
          axis_last <= next_axis_last;
        end if;
      end if;
    end process;

    axis_keep <= (others => '1');

    axis_rdy <= M_AXIS_TREADY;

  end generate SAME_WIDTH_GEN;


  AXI_WIDER_GEN : if (C_M_AXIS_TDATA_WIDTH > C_AP_ARG_DATA_WIDTH) generate
    -- Notes:
    -- This design is based on using a temporal register, where input data is
    -- stored before pushing to the FIFO. This register is used to pack
    -- received data and form an AXI-stream data beat. the last AXI-stream beat
    -- (TLAST high) will be the data stored in the register when we receive an
    -- ap_done. When we receive ap_done, two things could happen:
    --
    -- 1. New data is being written. this means ap_oarg_we = '1' and ap_oarg_full_n =
    --    '1'; that is, tap_0_we = '1'. the input data value should be accepted
    --    otherwise ap_done would not go high.
    --    a. if the temporal register is full, this new write will push the
    --       data to the fifo (fifo will always accept otherwise ap_oarg_full_n
    --       would be active and ap_done will not be generated). At the same time,
    --       this new data value into the temporal register. in the next cycle,
    --       we're in pending_last state, we have a incomplete data beat to write
    --       in the fifo (last AXI-stream beat).
    --    b. If the temporal register (tap_0) is incomplete, it can complete or
    --       not with this data write. In any case, the final content will be
    --       available next cycle (pendign_last state). in this state, it will
    --       be pushed to the FIFO labeled as last beat in stream.
    --
    -- 2. NO new data is being written. In this case, temporal register can be:
    --    * complete (full). signal tap_0_vld = '1'
    --    * partially complete. signal tap_0_strb(0)='1'. that is, at least,
    --      firt ap_word has data.
    --    * completely empty. This is not impossible case.
    --
    --    if regiter is complete or partially complete, it's content should be
    --    pushed to the FIFO. these two cases can be characterized by tap_0_strb(0)='1'
    --    to mantain coherence with case 1, this transfer to fifo will occur in
    --    the next state (pending_last), although in theory could happen in
    --    running state.
    --    there is a special condition. if we receive ap_done and we're not
    --    receiving new data and register is complete, we could try to transfer
    --    to the fifo.

    constant WORDS_PER_BEAT : integer := C_M_AXIS_TDATA_WIDTH/C_AP_ARG_DATA_WIDTH;
    signal   word_sel       : std_logic_vector(WORDS_PER_BEAT-1 downto 0);
    signal   word_clr       : std_logic;

    type state_type is (
      -- pragma translate_off
      stop,
      -- pragma translate_on
      idle,
      running,
      pending_last);
    signal state : state_type;

    signal tap_0       : std_logic_vector(C_M_AXIS_TDATA_WIDTH-1 downto 0);
    signal tap_0_we    : std_logic;
    signal tap_0_vld   : std_logic;
    signal tap_0_rdy   : std_logic;
    signal tap_0_start : std_logic;
    signal tap_0_end   : std_logic;
    signal tap_0_strb  : std_logic_vector(WORDS_PER_BEAT-1 downto 0);

    constant FIFO_DATA_LSB  : integer := 0;
    constant FIFO_DATA_MSB  : integer := C_M_AXIS_TDATA_WIDTH-1;
    constant FIFO_STRB_LSB  : integer := FIFO_DATA_MSB+1;
    constant FIFO_STRB_MSB  : integer := FIFO_STRB_LSB+WORDS_PER_BEAT-1;
    constant FIFO_START_BIT : integer := FIFO_STRB_MSB+1;
    constant FIFO_END_BIT   : integer := FIFO_START_BIT+1;
    constant FIFO_WIDTH     : integer := FIFO_END_BIT+1;

    signal fifo_din     : std_logic_vector(FIFO_WIDTH-1 downto 0);
    signal fifo_dout    : std_logic_vector(FIFO_WIDTH-1 downto 0);
    signal fifo_din_vld : std_logic;
    signal fifo_din_rdy : std_logic;

    -- tap_0 is an extra position for the FIFO; substract one
    constant DATA_RATIO : integer := C_M_AXIS_TDATA_WIDTH/C_AP_ARG_DATA_WIDTH;
    constant FIFO_DEPTH : integer := (2**(C_AP_ARG_ADDR_WIDTH-log2(DATA_RATIO)))-1;

    type axis_state_type is (
      -- pragma translate_off
      stop,
      -- pragma translate_on
      idle,
      running,
      discarding,
      padding);

    signal axis_state      : axis_state_type;
    signal apply_sw_length : std_logic;

    -- These are the signal for the FIFO output:
    signal dout         : std_logic_vector(C_M_AXIS_TDATA_WIDTH-1 downto 0);
    signal dout_word_en : std_logic_vector(WORDS_PER_BEAT-1 downto 0);
    signal dout_start   : std_logic;
    signal dout_end     : std_logic;
    signal dout_vld     : std_logic;
    signal dout_rdy     : std_logic;

    constant AXIS_BEAT_REM_WIDTH : integer := log2(DATA_RATIO);
    constant AXIS_BEAT_CNT_WIDTH : integer := SW_LENGTH_WIDTH-AXIS_BEAT_REM_WIDTH;
    constant AXIS_BEAT_CNT_LSB   : integer := AXIS_BEAT_REM_WIDTH;
    constant AXIS_BEAT_CNT_MSB   : integer := SW_LENGTH_WIDTH-1;

    -- AXI stream beat counter:
    signal axis_beat_cnt   : unsigned(AXIS_BEAT_CNT_WIDTH-1 downto 0);
    signal axis_beat_dec   : std_logic;
    signal axis_beat_clr   : std_logic;
    signal axis_beat_cnt_0 : std_logic;
    signal axis_beat_cnt_1 : std_logic;
    signal axis_beat_end   : std_logic;

    -- sw_length_with_rem is set when the configured SW length is not
    -- a integer multiple of C_M_AXIS_TDATA_WIDTH
    signal sw_length_with_rem : std_logic;
    -- In this case, sw_last_word_en provides the enabled words
    -- for last AXIS beat
    signal sw_last_word_en    : std_logic_vector(WORDS_PER_BEAT-1 downto 0);

    -- Output stage control:
    signal axis_ce : std_logic;
    signal axis_we : std_logic;

    -- These signals are used to generate tlast and tkeep for the output
    -- stage. next_axis_last marks the last beat. next_axis_word_en indicates
    -- the enabled words (those which have the tkeep bits activated). It will
    -- be unrolled to generate tkee. Finally, axis_word_vld indicates which
    -- words are going to keep their original value. Not valid words will be
    -- forced to zero during padding.
    signal next_axis_last    : std_logic;
    signal next_axis_word_en : std_logic_vector(WORDS_PER_BEAT-1 downto 0);
    signal axis_word_vld     : std_logic_vector(WORDS_PER_BEAT-1 downto 0);

    
    signal ap_oarg_full_n_i   : std_logic;

  begin
    -- With this shift register, we select the destination word within the
    -- temporal register
    process(ap_clk, ap_rst)
    begin
      if(ap_rst = '1') then
        word_sel    <= (others => '0');
        word_sel(0) <= '1';
      elsif(ap_clk'event and ap_clk = '1') then
        if(word_clr = '1') then
          word_sel    <= (others => '0');
          word_sel(0) <= '1';
        elsif(tap_0_we = '1') then
          word_sel <= word_sel(WORDS_PER_BEAT-2 downto 0) & word_sel(WORDS_PER_BEAT-1);
        end if;
      end if;
    end process;
    
    process(ap_clk)
    begin
      if(ap_clk'event and ap_clk = '1') then
        if(tap_0_we = '1') then
          for i in 0 to WORDS_PER_BEAT-1 loop
            if(word_sel(i) = '1') then
              tap_0(C_AP_ARG_DATA_WIDTH*(i+1)-1 downto C_AP_ARG_DATA_WIDTH*i) <= ap_oarg_din;
            end if;
          end loop;
        end if;
      end if;
    end process;

    process(ap_clk, ap_rst)
    begin
      if(ap_rst = '1') then
        tap_0_strb <= (others => '0');
      elsif(ap_clk'event and ap_clk = '1') then
        -- when the register value is taken, we clean strb, unless we are
        -- receiving the first word of the following beat
        if((fifo_din_vld and fifo_din_rdy) = '1') then
          tap_0_strb    <= (others => '0');
          tap_0_strb(0) <= tap_0_we;
        elsif(tap_0_we = '1') then
          -- In the rest of cases, we activate the correct bit
          tap_0_strb <= tap_0_strb or word_sel;
        end if;
      end if;
    end process;

    process(ap_clk, ap_rst)
    begin
      if(ap_rst = '1') then
        tap_0_vld <= '0';
      elsif(ap_clk'event and ap_clk = '1') then
        if(tap_0_vld = '0' or (tap_0_vld and tap_0_rdy) = '1') then
          -- The input reg has a new valid data value when:
          -- 1. a new data value is written to complte the fifo word (bit width)
          -- 2. a new data value is written at the same time ap_done is active
          -- (fifo word might be complete/incomplete)
          -- 3. we receive ap_done and there is data remaining in the register
          tap_0_vld <= (tap_0_we and (word_sel(WORDS_PER_BEAT-1))) or
                       (tap_0_we and ap_done);
        end if;
      end if;
    end process;


    process(ap_clk, ap_rst)
    begin
      if(ap_rst = '1') then
        state       <= idle;
        tap_0_start <= '0';
        ap_arg_rqt  <= '1';
      elsif(ap_clk'event and ap_clk = '1') then
        case state is
          when idle =>
            if(ap_start = '1') then
              state       <= running;
              tap_0_start <= '1';
            end if;
          when running =>
            if(ap_done = '1') then
              state      <= pending_last;
              ap_arg_rqt <= '0';
            end if;

            if((fifo_din_vld and fifo_din_rdy) = '1') then
              tap_0_start <= '0';
            end if;

          when pending_last =>
            if(tap_0_strb(0) = '0' or (tap_0_strb(0) and fifo_din_rdy) = '1') then
              state      <= idle;
              ap_arg_rqt <= '1';
            end if;
          when others =>
        end case;
      end if;
    end process;

    process(state, ap_oarg_we, tap_0_vld, fifo_din_rdy, tap_0_strb)
    begin
      ap_oarg_full_n_i <= '0';

      tap_0_we  <= '0';
      tap_0_rdy <= '0';

      tap_0_end <= '0';

      fifo_din_vld <= '0';
      
      word_clr <= '0';

      case state is
        when idle =>
          word_clr <= '1';
          ap_oarg_full_n_i <= '1';

        when running =>
          -- We enable writting in tap_0 when:
          --  1. it's empty or
          --  2. it's full and its contents can be transfered to the FIFO
          -- Write is efective when these two conditions are met and a new data
          -- value is received.
          tap_0_we <= ap_oarg_we and (not(tap_0_vld) or (tap_0_vld and fifo_din_rdy));

          -- We enable received new data if:
          -- 1. tap_0 is empty
          -- 2. tap_0 is full and its contents can be transfered ot the FIFO
          ap_oarg_full_n_i <= not(tap_0_vld) or (tap_0_vld and fifo_din_rdy);

          -- we write in the FIFO when:
          --  1. tap_0 is full and arrives a new input value or
          --  2. finishes execution (ap_done = '1'), no new data received (ap_oarg_we = '0')
          --  and tap_0 is not empty (tap_0_strb(0) = '1').
          fifo_din_vld <= (tap_0_vld and ap_oarg_we);

          -- If fifo write is efective, we take the contents of tap_0
          tap_0_rdy <= (tap_0_vld and ap_oarg_we);

        when pending_last =>
          tap_0_end <= '1';

          fifo_din_vld <= tap_0_strb(0);
          tap_0_rdy    <= fifo_din_rdy;

        when others =>
      end case;
    end process;

    ap_oarg_full_n <= ap_oarg_full_n_i;
    
    fifo_din(FIFO_DATA_MSB downto FIFO_DATA_LSB) <= tap_0;
    fifo_din(FIFO_STRB_MSB downto FIFO_STRB_LSB) <= tap_0_strb;
    fifo_din(FIFO_START_BIT)                     <= tap_0_start;
    fifo_din(FIFO_END_BIT)                       <= tap_0_end;


    FIFO_I : entity axis_accelerator_adapter_v2_1_6.s2s_async_fifo_wt
      generic map (
        C_FAMILY => C_FAMILY,
        C_MTBF_STAGES => C_MTBF_STAGES,
        DEPTH    => FIFO_DEPTH,
        WIDTH    => FIFO_WIDTH)
      port map (
        din      => fifo_din,
        din_vld  => fifo_din_vld,
        din_rdy  => fifo_din_rdy,
        wr_clk   => ap_clk,
        wr_rst   => ap_rst,
        dout     => fifo_dout,
        dout_vld => dout_vld,
        dout_rdy => dout_rdy,
        rd_clk   => M_AXIS_ACLK,
        rd_rst   => axis_rst);

    dout         <= fifo_dout(FIFO_DATA_MSB downto FIFO_DATA_LSB);
    dout_word_en <= fifo_dout(FIFO_STRB_MSB downto FIFO_STRB_LSB);
    dout_start   <= fifo_dout(FIFO_START_BIT);
    dout_end     <= fifo_dout(FIFO_END_BIT);

    -- This counter is used to control the number of AXIS beats set by the SW length
    process(M_AXIS_ACLK)
      variable aux : unsigned(AXIS_BEAT_CNT_WIDTH-1 downto 0);
    begin
      if(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        if(axis_beat_clr = '1') then
          aux           := unsigned(xd_sw_length(AXIS_BEAT_CNT_MSB downto AXIS_BEAT_CNT_LSB));
          axis_beat_cnt <= aux;
        elsif(axis_beat_dec = '1') then
          axis_beat_cnt <= axis_beat_cnt-1;
        end if;
      end if;
    end process;

    -- This register is initialized when the axis_beat_cnt counter (SW length) is
    -- loaded. It's used to determine if the last beat is full (no remainder)
    process(M_AXIS_ACLK)
      variable beat_rem       : unsigned(AXIS_BEAT_REM_WIDTH-1 downto 0);
      variable upper_word_en  : unsigned(AXIS_BEAT_REM_WIDTH-1 downto 0);
      constant BYTES_PER_WORD : integer := C_AP_ARG_DATA_WIDTH/8;
    begin
      if(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        if(axis_beat_clr = '1') then
          beat_rem := unsigned(xd_sw_length(AXIS_BEAT_REM_WIDTH-1 downto 0));
          if(beat_rem = 0) then
            sw_length_with_rem <= '0';
          else
            sw_length_with_rem <= '1';
          end if;

          upper_word_en := unsigned(xd_sw_length(AXIS_BEAT_CNT_LSB-1 downto 0)) - 1;
          for i in 0 to WORDS_PER_BEAT-1 loop
            if(i > upper_word_en) then
              sw_last_word_en(i) <= '0';
            else
              sw_last_word_en(i) <= '1';
            end if;
          end loop;
        end if;
      end if;
    end process;

    process(axis_beat_cnt)
    begin
      axis_beat_cnt_0 <= '0';
      axis_beat_cnt_1 <= '0';
      if(axis_beat_cnt(axis_beat_CNT_WIDTH-1 downto 1) = 0) then
        axis_beat_cnt_0 <= not(axis_beat_cnt(0));
        axis_beat_cnt_1 <= axis_beat_cnt(0);
      end if;
    end process;

    axis_beat_end <= axis_beat_cnt_1 when (sw_length_with_rem = '0') else axis_beat_cnt_0;

    process(M_AXIS_ACLK, ap_rst_axi)
    begin
      if(ap_rst_axi = '1') then
        axis_state      <= idle;
        apply_sw_length <= '0';
      elsif(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        case axis_state is
          when idle =>
            -- Don't start until the first data value of a new frame
            -- is available:
            if((dout_vld and dout_start) = '1') then
              apply_sw_length <= use_sw_length;
              -- Wait for a valid SW length if it's going to be used
              if(use_sw_length = '1') then
                if(xd_sw_length_vld = '1') then
                  axis_state <= running;
                end if;
              else
                axis_state <= running;
              end if;
            end if;
          when running =>
            if((axis_ce and dout_vld) = '1') then
              if(apply_sw_length = '0') then
                if(dout_end = '1') then
                  axis_state <= idle;
                end if;
              else
                if(axis_beat_end = '0' and dout_end = '1') then
                  axis_state <= padding;
                elsif(axis_beat_end = '1' and dout_end = '0') then
                  axis_state <= discarding;
                elsif(axis_beat_end = '1' and dout_end = '1') then
                  axis_state <= idle;
                end if;
              end if;
            end if;
          when discarding =>
            if(dout_end = '1') then
              axis_state <= idle;
            end if;
          when padding =>
            if((axis_ce and axis_beat_end) = '1') then
              axis_state <= idle;
            end if;
          when others =>
        end case;
      end if;
    end process;

    process(axis_state, use_sw_length, dout_start, dout_vld, axis_ce, dout_end, dout_word_en, axis_beat_end, sw_last_word_en)
      constant BYTES_PER_WORD  : integer := C_AP_ARG_DATA_WIDTH/8;
      constant AXIS_KEEP_WIDTH : integer := C_M_AXIS_TDATA_WIDTH/8;
    begin
      xd_sw_length_rdy <= '0';

      axis_beat_clr <= '0';
      axis_beat_dec <= '0';

      dout_rdy <= '0';
      axis_we  <= '0';

      next_axis_last    <= '0';
      axis_word_vld     <= (others => '0');  -- used during padding to fill with zeros
      next_axis_word_en <= (others => '0');  -- used to generate axis_keep


      case axis_state is
        when idle =>
          xd_sw_length_rdy <= use_sw_length and dout_start and dout_vld;
          axis_beat_clr    <= '1';
        when running =>
          axis_we       <= dout_vld;
          dout_rdy      <= axis_ce and dout_vld;
          axis_beat_dec <= axis_ce and dout_vld;

          if(use_sw_length = '0') then
            next_axis_last    <= dout_end;
            next_axis_word_en <= dout_word_en;
            axis_word_vld     <= dout_word_en;
          else
            if(axis_beat_end = '0' and dout_end = '0') then  -- normal opperation
              next_axis_last    <= '0';
              next_axis_word_en <= (others => '1');
              axis_word_vld     <= dout_word_en;
            elsif(axis_beat_end = '0' and dout_end = '1') then  -- doing padding
              next_axis_last    <= '0';
              next_axis_word_en <= (others => '1');
              axis_word_vld     <= dout_word_en;
            elsif(axis_beat_end = '1' and dout_end = '0') then  -- doing discarding
              next_axis_last    <= '1';
              next_axis_word_en <= sw_last_word_en;
              axis_word_vld     <= sw_last_word_en;
            elsif(axis_beat_end = '1' and dout_end = '1') then  -- sw_length = hw_length
              -- We get here when the number of HW beats is equal to the number of
              -- SW beats. It doesn't necessary mean that sw_length = hw_length
              -- because the remainders can be different.
              -- In this case the enabled words (the ones which have tkeep
              -- at '1') are controled by SW. The valid words (the ones which
              -- are not forced to zero) are most restrictive one because
              -- padding or discarding can being carried out.
              next_axis_last    <= '1';
              next_axis_word_en <= sw_last_word_en;
              axis_word_vld     <= dout_word_en and sw_last_word_en;
            end if;
          end if;

        when discarding =>
          dout_rdy <= '1';

        when padding =>
          axis_we        <= '1';
          axis_beat_dec  <= axis_ce;
          next_axis_last <= axis_beat_end;
          if(axis_beat_end = '0') then
            next_axis_word_en <= (others => '1');
          else
            next_axis_word_en <= sw_last_word_en;
          end if;
        when others =>
      end case;
    end process;

    axis_ce <= not(axis_vld) or (axis_vld and axis_rdy);

    process(M_AXIS_ACLK, ap_rst_axi)
    begin
      if(ap_rst_axi = '1') then
        axis_vld <= '0';
      elsif(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        if(axis_ce = '1') then
          axis_vld <= axis_we;
        end if;
      end if;
    end process;

    process(M_AXIS_ACLK)
      constant BYTES_PER_WORD : integer := C_AP_ARG_DATA_WIDTH/8;
    begin
      if(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        if(axis_ce = '1') then
          axis_data <= (others => '0');
          for i in 0 to WORDS_PER_BEAT-1 loop
            if (axis_word_vld(i) = '1') then
              axis_data(C_AP_ARG_DATA_WIDTH*(i+1)-1 downto C_AP_ARG_DATA_WIDTH*i) <=
                dout(C_AP_ARG_DATA_WIDTH*(i+1)-1 downto C_AP_ARG_DATA_WIDTH*i);
            end if;
          end loop;
          axis_last <= next_axis_last;
          -- unroll axis_beat_en to get axis_keep
          for i in 0 to WORDS_PER_BEAT-1 loop
            axis_keep(BYTES_PER_WORD*(i+1)-1 downto BYTES_PER_WORD*i) <=
              (others => next_axis_word_en(i));
          end loop;
        end if;
      end if;
    end process;

    axis_rdy <= M_AXIS_TREADY;

  end generate AXI_WIDER_GEN;

  AXI_NARROWER_GEN : if (C_M_AXIS_TDATA_WIDTH < C_AP_ARG_DATA_WIDTH) generate
    signal tap_0       : std_logic_vector(C_AP_ARG_DATA_WIDTH-1 downto 0);
    signal tap_0_we    : std_logic;
    signal tap_0_vld   : std_logic;
    signal tap_0_rdy   : std_logic;
    signal tap_0_start : std_logic;
    signal tap_0_end   : std_logic;

    constant FIFO_DATA_LSB  : integer := 0;
    constant FIFO_DATA_MSB  : integer := C_AP_ARG_DATA_WIDTH-1;
    constant FIFO_START_BIT : integer := FIFO_DATA_MSB+1;
    constant FIFO_END_BIT   : integer := FIFO_START_BIT+1;
    constant FIFO_WIDTH     : integer := FIFO_END_BIT+1;

    signal fifo_din      : std_logic_vector(FIFO_WIDTH-1 downto 0);
    signal fifo_din_vld  : std_logic;
    signal fifo_din_rdy  : std_logic;
    signal fifo_dout     : std_logic_vector(FIFO_WIDTH-1 downto 0);
    signal fifo_dout_vld : std_logic;
    signal fifo_dout_rdy : std_logic;

    type state_type is (
      -- pragma translate_off
      stop,
      -- pragma translate_on
      idle,
      running,
      pending_last);
    signal state : state_type;

    -- tap_0 is an extra position for the FIFO; substract one
    constant FIFO_DEPTH : integer := (2**C_AP_ARG_ADDR_WIDTH)-1;

    type axis_state_type is (
      -- pragma translate_off
      stop,
      -- pragma translate_on
      idle,
      running,
      discarding,
      padding);

    signal axis_state      : axis_state_type;
    signal apply_sw_length : std_logic;

    -- These are the signal for the FIFO output:
    signal dout       : std_logic_vector(C_AP_ARG_DATA_WIDTH-1 downto 0);
    signal dout_start : std_logic;
    signal dout_end   : std_logic;
    signal dout_vld   : std_logic;
    signal dout_rdy   : std_logic;

    -- Next signals are used to implement a counter to count the
    -- axi beats needed to transmit each core word.
    constant BEATS_PER_WORD : integer := C_AP_ARG_DATA_WIDTH/C_M_AXIS_TDATA_WIDTH;
    constant BEAT_CNT_WIDTH : integer := log2(BEATS_PER_WORD);
    signal   beat_cnt       : unsigned(BEAT_CNT_WIDTH-1 downto 0);
    signal   beat_inc       : std_logic;
    signal   beat_clr       : std_logic;
    signal   beat_end       : std_logic;

    constant AXIS_WORD_CNT_WIDTH : integer := SW_LENGTH_WIDTH;

    -- AXI stream ap_word counter:
    signal axis_word_cnt : unsigned(AXIS_WORD_CNT_WIDTH-1 downto 0);
    signal axis_word_dec : std_logic;
    signal axis_word_clr : std_logic;
    signal axis_word_end : std_logic;

    -- Output stage control:
    signal axis_ce        : std_logic;
    signal axis_we        : std_logic;
    signal next_axis_last : std_logic;
    signal axis_word_vld  : std_logic;

  begin

    process(ap_clk)
    begin
      if(ap_clk'event and ap_clk = '1') then
        if(tap_0_we = '1') then
          tap_0 <= ap_oarg_din;
        end if;
      end if;
    end process;

    process(ap_clk, ap_rst)
    begin
      if(ap_rst = '1') then
        tap_0_vld <= '0';
      elsif(ap_clk'event and ap_clk = '1') then
        if(tap_0_vld = '0' or (tap_0_vld and tap_0_rdy) = '1') then
          tap_0_vld <= tap_0_we;
        end if;
      end if;
    end process;

    process(ap_clk, ap_rst)
    begin
      if(ap_rst = '1') then
        state       <= idle;
        tap_0_start <= '0';
        ap_arg_rqt  <= '1';
      elsif(ap_clk'event and ap_clk = '1') then
        case state is
          when idle =>
            if(ap_start = '1') then
              state       <= running;
              tap_0_start <= '1';
            end if;
          when running =>
            if(ap_done = '1') then
              if (ap_oarg_we = '0' and fifo_din_rdy = '1') then
                state <= idle;
              else
                state      <= pending_last;
                ap_arg_rqt <= '0';
              end if;
            end if;

            if((fifo_din_vld and fifo_din_rdy) = '1') then
              tap_0_start <= '0';
            end if;

          when pending_last =>
            if(tap_0_vld = '0' or (tap_0_vld and fifo_din_rdy) = '1') then
              state      <= idle;
              ap_arg_rqt <= '1';
            end if;
          when others =>
        end case;
      end if;
    end process;

    process(state, ap_oarg_we, tap_0_vld, fifo_din_rdy, ap_done)
    begin
      ap_oarg_full_n <= '0';

      tap_0_we  <= '0';
      tap_0_rdy <= '0';
      tap_0_end <= '0';

      fifo_din_vld <= '0';

      case state is
        when idle =>
          ap_oarg_full_n <= '1';

        when running =>
          -- We write in tap_0 when:
          --  1. it's empty or
          --  2. it's full and it's content can be transfered to the FIFO.
          -- Write is efective when these two conditions are met and new data arrives.
          tap_0_we <= ap_oarg_we and (not(tap_0_vld) or (tap_0_vld and fifo_din_rdy));

          -- We enable receiving new data if:
          -- 1. tap_0 is empty
          -- 2. tap_0 is full and its contents can be transfered to the FIFO
          ap_oarg_full_n <= not(tap_0_vld) or (tap_0_vld and fifo_din_rdy);

          -- Write in the FIFO when tap_0 is full and:
          --  1. arrived a new data value at the input or
          --  2. we've received the last data beat (ap_done = '1')
          fifo_din_vld <= tap_0_vld and (ap_oarg_we or ap_done);

          -- If write in the fifo is efective, we take the contents of tap_0:
          -- We take contents of tap_0 when FIFO accepts the data
          tap_0_rdy <= tap_0_vld and (ap_oarg_we or ap_done) and fifo_din_rdy;

          -- It's the last data if the write in the fifo is due to ap_done:
          tap_0_end <= tap_0_vld and ap_done;

        when pending_last =>
          tap_0_end <= '1';

          -- Write in the fifo when tap_0 is full and arrives a new data at the
          -- input:
          fifo_din_vld <= tap_0_vld;
          -- At that moment, we take the contents of tap_0:
          tap_0_rdy    <= tap_0_vld and fifo_din_rdy;

        when others =>
      end case;
    end process;

    fifo_din(FIFO_DATA_MSB downto FIFO_DATA_LSB) <= tap_0;
    fifo_din(FIFO_START_BIT)                     <= tap_0_start;
    fifo_din(FIFO_END_BIT)                       <= tap_0_end;

    FIFO_I : entity axis_accelerator_adapter_v2_1_6.s2s_async_fifo_wt
      generic map (
        C_FAMILY => C_FAMILY,
        C_MTBF_STAGES => C_MTBF_STAGES,
        DEPTH    => FIFO_DEPTH,
        WIDTH    => FIFO_WIDTH)
      port map (
        din      => fifo_din,
        din_vld  => fifo_din_vld,
        din_rdy  => fifo_din_rdy,
        wr_clk   => ap_clk,
        wr_rst   => ap_rst,
        dout     => fifo_dout,
        dout_vld => dout_vld,
        dout_rdy => dout_rdy,
        rd_clk   => M_AXIS_ACLK,
        rd_rst   => axis_rst);

    dout       <= fifo_dout(FIFO_DATA_MSB downto FIFO_DATA_LSB);
    dout_start <= fifo_dout(FIFO_START_BIT);
    dout_end   <= fifo_dout(FIFO_END_BIT);

    process(M_AXIS_ACLK)
    begin
      if(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        if(axis_word_clr = '1') then
          axis_word_cnt <= unsigned(xd_sw_length);
        elsif(axis_word_dec = '1') then
          axis_word_cnt <= axis_word_cnt-1;
        end if;
      end if;
    end process;

    axis_word_end <= '1' when (axis_word_cnt = 1) else '0';

    process(M_AXIS_ACLK, ap_rst_axi)
    begin
      if(ap_rst_axi = '1') then
        axis_state      <= idle;
        apply_sw_length <= '0';
      elsif(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        case axis_state is
          when idle =>
            -- Don't start until the first datum of a new frame
            -- is available:
            if((dout_vld and dout_start) = '1') then
              apply_sw_length <= use_sw_length;
              -- Wait for a valid SW length if it's going to be used
              if(use_sw_length = '1') then
                if(xd_sw_length_vld = '1') then
                  axis_state <= running;
                end if;
              else
                axis_state <= running;
              end if;
            end if;
          when running =>
            if((axis_ce and dout_vld and beat_end) = '1') then
              if(apply_sw_length = '0') then
                if(dout_end = '1') then
                  axis_state <= idle;
                end if;
              else
                if(axis_word_end = '0' and dout_end = '1') then
                  axis_state <= padding;
                elsif(axis_word_end = '1' and dout_end = '0') then
                  axis_state <= discarding;
                elsif(axis_word_end = '1' and dout_end = '1') then
                  axis_state <= idle;
                end if;
              end if;
            end if;
          when discarding =>
            if(dout_end = '1') then
              axis_state <= idle;
            end if;
          when padding =>
            if((axis_ce and axis_word_end and beat_end) = '1') then
              axis_state <= idle;
            end if;
          when others =>
        end case;
      end if;
    end process;

    process(axis_state, use_sw_length, dout_start, dout_vld, axis_ce, axis_word_end, dout_end, beat_end)
    begin
      xd_sw_length_rdy <= '0';
      axis_word_clr    <= '0';
      axis_word_dec    <= '0';
      dout_rdy         <= '0';
      axis_we          <= '0';
      next_axis_last   <= '0';
      axis_word_vld    <= '0';
      beat_inc         <= '0';

      case axis_state is
        when idle =>
          xd_sw_length_rdy <= use_sw_length and dout_start and dout_vld;
          axis_word_clr    <= '1';
        when running =>
          axis_word_clr <= '0';
          axis_we       <= dout_vld;

          -- Consume the FIFO output when the last beat of the ap_word is
          -- transfered to the output reg:
          dout_rdy      <= axis_ce and dout_vld and beat_end;
          axis_word_dec <= axis_ce and dout_vld and beat_end;
          beat_inc      <= axis_ce and dout_vld;

          if(use_sw_length = '0') then
            next_axis_last <= dout_end and beat_end;
            axis_word_vld  <= '1';
          else
            if(axis_word_end = '0' and dout_end = '0') then  -- normal opperation
              next_axis_last <= '0';
              axis_word_vld  <= '1';
            elsif(axis_word_end = '0' and dout_end = '1') then  -- doing padding
              next_axis_last <= '0';
              axis_word_vld  <= '1';
            elsif(axis_word_end = '1' and dout_end = '0') then  -- doing discarding
              next_axis_last <= beat_end;
              axis_word_vld  <= '1';
            elsif(axis_word_end = '1' and dout_end = '1') then  -- sw_length = hw_length
              next_axis_last <= beat_end;
              axis_word_vld  <= '1';
            end if;
          end if;
        when discarding =>
          dout_rdy <= '1';
        when padding =>
          axis_we       <= '1';
          axis_word_dec <= axis_ce and beat_end;
          beat_inc      <= axis_ce;

          next_axis_last <= axis_word_end and beat_end;
          axis_word_vld  <= '0';
        when others =>
      end case;
    end process;

    -- Increment beat_cnt each time a beat is transfered to the output tap:
    process(M_AXIS_ACLK, axis_rst)
    begin
      if(axis_rst = '1') then
        beat_cnt <= (others => '0');
      elsif(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        if(beat_inc = '1') then
          beat_cnt <= beat_cnt + 1;
        end if;
      end if;
    end process;

    beat_end <= '1' when (beat_cnt = BEATS_PER_WORD-1) else '0';

    axis_ce <= not(axis_vld) or (axis_vld and axis_rdy);

    process(M_AXIS_ACLK, axis_rst)
    begin
      if(axis_rst = '1') then
        axis_vld <= '0';
      elsif(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        if(axis_ce = '1') then
          axis_vld <= axis_we;
        end if;
      end if;
    end process;

    -- Output register:
    process(M_AXIS_ACLK)
      variable aux : std_logic_vector(C_AP_ARG_DATA_WIDTH-1 downto 0);
    begin
      if(M_AXIS_ACLK'event and M_AXIS_ACLK = '1') then
        if(axis_ce = '1') then
          axis_data <= (others => '0');
          if(axis_word_vld = '1') then
            aux := fifo_dout(FIFO_DATA_MSB downto FIFO_DATA_LSB);
            for i in 0 to BEATS_PER_WORD-1 loop
              if (i = beat_cnt) then
                axis_data <= aux(C_M_AXIS_TDATA_WIDTH*(i+1)-1 downto C_M_AXIS_TDATA_WIDTH*i);
              end if;
            end loop;
          end if;
          axis_last <= next_axis_last;
        end if;
      end if;
    end process;

    axis_keep <= (others => '1');

    axis_rdy <= M_AXIS_TREADY;

  end generate AXI_NARROWER_GEN;

end rtl;

